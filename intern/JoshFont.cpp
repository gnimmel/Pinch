#include "joshfont.h"#include "jttoolkit.h"//static Vector *persisPts;JoshFont::JoshFont(char file[], int lettersize,int renderStyle, int antialiased,int mipmap){  rendermode = GL_POLYGON;  open(file,lettersize, renderStyle, antialiased,mipmap);}JoshFont::~JoshFont(){  //dispose of the memory  FT_Done_Face    ( ft_face );  FT_Done_FreeType( ft_library );}int JoshFont::open(char file[], int lettersize,int renderstyle, int antialiased,int mipmap){  initsize = lettersize;  int ii;  int texturesize;  if(lettersize<= 4 &&lettersize> 2 ){    texturesize = 4;  } else if(lettersize<= 8 &&lettersize> 4 ){    texturesize = 8;  } else if(lettersize<= 16 &&lettersize> 8 ){    texturesize = 16;  } else if(lettersize<= 32 &&lettersize> 16 ){    texturesize = 32;  } else if(lettersize<= 64 &&lettersize> 32 ){    texturesize = 64;  } else if(lettersize<= 128 &&lettersize> 64 ){    texturesize = 128;  } else if(lettersize<= 256 &&lettersize> 128 ){    texturesize = 256;  } else if(lettersize<= 512 &&lettersize> 256 ){    texturesize = 512;  } else {    texturesize = 1024;  }  base = glGenLists(256);  //load the images into textures and make them into gllists.    int err = FT_Init_FreeType(&ft_library);    if(err){    printf("error initializing freetype2: %i\n",err);    exit(0);      }  err = FT_New_Face(ft_library,file,0,&ft_face);  if(err==FT_Err_Unknown_File_Format){    printf("error: the font file could be\  opened and read, but it appears that its font format is unsupported\n");    return err;  } else if(err){    printf("error opening font: %i\n",err);    return err;  }  //report  //   printf("font info:\n",0);  //   printf("  num_faces: %i\n",ft_face->num_faces);  //   printf("  num_glyphs: %i\n",ft_face->num_glyphs);  //   printf("  units_per_EM: %i\n",ft_face->units_per_EM);  //   printf("  size: %i\n",ft_face->size);    //generate a sample bitmap  err = FT_Set_Pixel_Sizes(ft_face,0,lettersize);  if(err)printf("there was an error\n: %i\n",err);    units_per_EM = ft_face->units_per_EM;  ascender = ft_face->ascender;  descender = ft_face->descender;  //now render all 256 characters  for(int i=0;i<256;i++){    //err = FT_Load_Char(ft_face,'4',FT_LOAD_RENDER);    int glyph_index = FT_Get_Char_Index(ft_face, i);    err = FT_Load_Glyph(ft_face,glyph_index,FT_LOAD_DEFAULT );    if(err)printf("there was an error\n: %i\n",err);    #if defined(__DARWIN__)#define RENDER_NORMAL FT_RENDER_MODE_NORMAL#else#define RENDER_NORMAL ft_render_mode_normal#endif    FT_Glyph g;    FT_Get_Glyph (ft_face->glyph, &g);    err = FT_Render_Glyph(ft_face->glyph,RENDER_NORMAL);    if(err)printf("there was an error\n: %i\n",err);    FT_GlyphSlot slot = ft_face->glyph;        //printf("rows: %i\n",slot->bitmap.rows);    //printf("width: %i\n",slot->bitmap.width);    //printf("pitch: %i\n",slot->bitmap.pitch);        if( ft_glyph_format_outline != g->format){      //printf("not outline format\n");    } else {      //printf("yes outline format\n");    }    //do something with the vectors.        FT_OutlineGlyph outline = (FT_OutlineGlyph)g;    FT_Outline ftOutline = outline->outline;    //make tex from loading the bitmap buffer into openGL.    if(!antialiased){      //do a posterize filter on the bitmap.      for(ii=0;ii<slot->bitmap.rows*slot->bitmap.width;ii++){	if(slot->bitmap.buffer[ii]>128){	  slot->bitmap.buffer[ii] = 255;	} else {	  slot->bitmap.buffer[ii] = 0;	}      }    }        //record kerning info.    charWidths[i] = ((float)(slot->metrics.width)/(float)((texturesize*64)));    charHeights[i] = ((float)(slot->metrics.height)/(float)((texturesize*64)));    charHoriBearingYs[i] = ((float)(slot->metrics.horiBearingY)/(float)((texturesize*64)));    charHoriBearingXs[i] = ((float)(slot->metrics.horiBearingX)/(float)((texturesize*64)));    charHoriAdvances[i] = ((float)(slot->metrics.horiAdvance)/(float)((texturesize*64)));    if(i=='\t')charHoriAdvances[i] = 4;    charVertBearingYs[i] = ((float)(slot->metrics.vertBearingY)/(float)((texturesize*64)));    charVertBearingXs[i] = ((float)(slot->metrics.vertBearingX)/(float)((texturesize*64)));    charVertAdvances[i] = ((float)(slot->metrics.vertAdvance)/(float)((texturesize*64)));    //printf("%c %f\n",i,charHoriBearingYs[i]);        int tex;        if(renderstyle==JF_BITMAP){      tex = loadBitmapCharRAWFromMemory(slot->bitmap.buffer,					texturesize,texturesize,slot->bitmap.width,					slot->bitmap.rows,mipmap);    }else if(renderstyle==JF_VECTOR){      tex = 0;    }    //int tex = 0;            //persisPts = new Vector();        glNewList(base+i,GL_COMPILE);        float trans = -1.0;        if(renderstyle==JF_BITMAP){            //textures[i] = tex;      if(tex!=0){	glTranslatef(0,trans,0);	glBindTexture(GL_TEXTURE_2D,tex);	     	glBegin(GL_QUADS);     	glTexCoord2f(0,0);     	glVertex2f(0,0);	     	glTexCoord2f(1,0);     	glVertex2f(1,0);	     	glTexCoord2f(1,1);     	glVertex2f(1,1);	     	glTexCoord2f(0,1);     	glVertex2f(0,1);     	glEnd();	glBindTexture(GL_TEXTURE_2D,0);		glTranslatef(0,-trans,0);      }    }        //debugging tool    //     if(0){    //       if(ftOutline.n_points>0){    // 	glBindTexture(GL_TEXTURE_2D,0);    // 	//glColor3f(0,0,0);    // 	glDisable(GL_BLEND);    // 	JTTessBegin();    // 	if(ftOutline.n_contours>0){    // 	  int curContourIndex=0;    // 	  int curCloser = ftOutline.contours[0];    // 	  for(int cii=0;cii<ftOutline.n_points;cii++){    // 	    JTTessVertex(ftOutline.points[cii].x/(64.0*lettersize),    // 			 ftOutline.points[cii].y/(64.0*lettersize),0);        // 	    if(curCloser==cii){    // 	      JTTessNewContour();    // 	      if(curContourIndex+2<ftOutline.n_contours) {    // 		curContourIndex++;    // 		curCloser = ftOutline.contours[curContourIndex];    // 	      }    // 	    }    // 	  }    // 	}        // 	JTTessEnd();    //       }    //     }    if(renderstyle==JF_VECTOR)tessChar(i,lettersize);        if(0){//render each of the vertex points too.      glBegin(GL_POINTS);      float w = ascender/(64.0*lettersize)-charHoriBearingYs[i];            for(int vci=0;vci<ftOutline.n_points;vci++){	if(ftOutline.tags[vci]==0)glColor3f(1,0,0);	else glColor3f(0,1,0);		float x = ftOutline.points[vci].x/(64.0*lettersize);	float y = -ftOutline.points[vci].y/(64.0*lettersize)-w;	glVertex3f(x,y,0);	//glRectf(x-0.01,y-0.01,x+0.01,y+0.01);      }      glEnd();    }    glEndList();        if(renderstyle==JF_VECTOR)feedbackChar(i,lettersize);//record some triangles.      }  glBindTexture(GL_TEXTURE_2D,0);}void JoshFont::drawChar(char c){  glCallList(base+c);}void JoshFont::feedbackChar(char i,float lettersize){  //call tessChar and catch the feedback.  feedbackScale = 640;//width();  feedbackBuffers[i] = new float[1024*256];//this should be enough, or the size will return -1.  glFeedbackBuffer(1024*256, GL_2D ,feedbackBuffers[i]);  glRenderMode(GL_FEEDBACK);  glPushMatrix();  glTranslatef(0,feedbackScale/2.0,0);  glScalef(feedbackScale/2.0,feedbackScale/2.0,0);  tessChar(i,lettersize);  glPopMatrix();  feedbackSizes[i] = glRenderMode(GL_RENDER);  if(feedbackSizes[i]==-1){    printf("error: glFeedback not enough buffer space for this list.\n",0);  }}void JoshFont::drawTriangleChar(char c,float size){    float *buffer = feedbackBuffers[c];  float bsize = feedbackSizes[c];  glPushMatrix();  glScalef(1,-1,1);  glScalef(size/(initsize*5),size/(initsize*5),1);  glTranslatef(0,-160.16,0);  int i=-1;  while(i+1<bsize){    //get a block    i++;    float block = buffer[i];    if(block==GL_POLYGON_TOKEN){      //printf("GL_POLYGON_TOKEN ",block);            i++;      int vcount = round(buffer[i]);      //printf("n=%i ",vcount);      glBegin(rendermode);      for(int ii=0;ii<vcount;ii++){	i++;	GLfloat x = (GLfloat)buffer[i];	//printf("x=%f ",x);	i++;	GLfloat y = ((GLfloat)buffer[i]);	//printf("y=%f ",y);	glVertex3f(x,y,0);      }      glEnd();      //printf("\n",0);    } else if(block==GL_POINT_TOKEN){      printf("GL_POINT_TOKEN \n",block);    } else if(block==GL_LINE_TOKEN){      printf("GL_LINE_TOKEN \n",block);    } else if(block==GL_LINE_RESET_TOKEN){      printf("GL_LINE_RESET_TOKEN \n",block);    } else if(block==GL_PASS_THROUGH_TOKEN){      printf("GL_PASS_THROUGH_TOKEN \n",block);          } else {      printf("%f <-- unrecognized\n",block);      i++;//see if we can pull ourselves out of that.    }  }  glPopMatrix();}void JoshFont::initFeedback(){  }void JoshFont::tessChar(char i,float lettersize){  if(1){    int glyph_index = FT_Get_Char_Index(ft_face, i);    int err = FT_Load_Glyph(ft_face,glyph_index,FT_LOAD_DEFAULT );    if(err)printf("there was an error\n: %i\n",err);        //int err;    FT_Glyph g;    FT_Get_Glyph (ft_face->glyph, &g);    //err = FT_Render_Glyph(ft_face->glyph,RENDER_NORMAL);    //if(err)printf("there was an error\n: %i\n",err);    FT_GlyphSlot slot = ft_face->glyph;    // printf("rows: %i\n",slot->bitmap.rows);    //     printf("width: %i\n",slot->bitmap.width);    //     printf("pitch: %i\n",slot->bitmap.pitch);        if( ft_glyph_format_outline != g->format){      //printf("not outline format\n");    } else {      //printf("yes outline format\n");    }    //do something with the vectors.        FT_OutlineGlyph outline = (FT_OutlineGlyph)g;    FT_Outline ftOutline = outline->outline;    //debugging incompat btwn tess and font paths.    //now this is the VECTOR VERSION of the preceding rendering routine!    glBindTexture(GL_TEXTURE_2D,0);    //glColor3f(0,0,0);    //glDisable(GL_BLEND);    JTTessBegin();    //printf("contours:%i\n", ftOutline.n_points);    if(ftOutline.n_contours>0){      //first copy all the points into their own gluTess compatible persistent points.      float w = ascender/(64.0*lettersize)-charHoriBearingYs[i];            //glPushMatrix();            //glTranslatef(0,w,0);      //GLUtesselator*tess = getTessObj();            ///gluTessBeginPolygon(tess,NULL);      //gluTessBeginContour(tess);            //for(int j=0;j<5;j++){            //}            int curContourIndex=0;      int curContour=ftOutline.contours[0];      int bezcount = 0;      int bezaccum[64];      for(int ii=0;ii<ftOutline.n_points;ii++){	FT_Vector v = ftOutline.points[ii];	//printf("%c %i %i %i\n",i,ftOutline.tags[ii],v.x/64,v.y/64);	if(ftOutline.tags[ii]==1){	  	  if(bezcount!=0){	    //new mutli bez event.	    	    for(int thisB=0;thisB<bezcount;thisB++){	      	      //aligning the points with the function	      int thisp = bezaccum[thisB];//this bez point.	      	      //here is the function.#define BEZIER_STEP_SIZE 0.22	      float bezierValues[2][2];	      float controlPoints[3][2];	      	      controlPoints[1][0] = ftOutline.points[thisp  ].x;	      controlPoints[1][1] = ftOutline.points[thisp  ].y;	      int virtualfirst = ((curContourIndex>0)?(ftOutline.contours[curContourIndex-1]+1):0);	      if (thisp==virtualfirst) {//the one after the last contour's end, or the very first one in the whole array.		controlPoints[0][0] = ftOutline.points[curContour].x;		controlPoints[0][1] = ftOutline.points[curContour].y;		controlPoints[2][0] = ftOutline.points[thisp+1].x;		controlPoints[2][1] = ftOutline.points[thisp+1].y;	      } else if (thisp==curContour) {		controlPoints[0][0] = ftOutline.points[thisp-1].x;		controlPoints[0][1] = ftOutline.points[thisp-1].y;		controlPoints[2][0] = ftOutline.points[virtualfirst].x;		controlPoints[2][1] = ftOutline.points[virtualfirst].y;	      } else {		controlPoints[0][0] = ftOutline.points[thisp-1].x;		controlPoints[0][1] = ftOutline.points[thisp-1].y;		controlPoints[2][0] = ftOutline.points[thisp+1].x;		controlPoints[2][1] = ftOutline.points[thisp+1].y;	      }	      for( unsigned int bi = 0; bi <= ( 1.0f / BEZIER_STEP_SIZE); bi++){		float t = static_cast<float>(bi) * BEZIER_STEP_SIZE;						bezierValues[0][0] = (1.0f - t) * controlPoints[0][0] + t * controlPoints[1][0];		bezierValues[0][1] = (1.0f - t) * controlPoints[0][1] + t * controlPoints[1][1];				bezierValues[1][0] = (1.0f - t) * controlPoints[1][0] + t * controlPoints[2][0];		bezierValues[1][1] = (1.0f - t) * controlPoints[1][1] + t * controlPoints[2][1];				bezierValues[0][0] = (1.0f - t) * bezierValues[0][0] + t * bezierValues[1][0];		bezierValues[0][1] = (1.0f - t) * bezierValues[0][1] + t * bezierValues[1][1];				//AddPoint( bezierValues[0][0], bezierValues[0][1]);		 		GLdouble d[12]; 		d[0] = (bezierValues[0][0]/(64.0*lettersize)+0.000001); 		d[1] = -(bezierValues[0][1]/(64.0*lettersize))-w; 		d[2] = 0; 		d[3] = 0; 		//persisPts->push((long)d);		JTTessVertex(d[0],d[1],0);	      }//end of beszier function 	      	      	      	      /*		GLdouble d[12];		d[0] = (ftOutline.points[thisp].x/(64.0*lettersize)+ii*0.0001);		d[1] = -(ftOutline.points[thisp].y/(64.0*lettersize)+ii*0.0001)-w;		d[2] = 0;		d[3] = 0;		JTTessVertex(d[0],d[1],0);	      */	      	      //add a moveTo	      if(curContour==thisp){		//persisPts->push(0);		JTTessNewContour();		curContourIndex++;		curContour=ftOutline.contours[curContourIndex];	      }	      //	      	    }//end of looping through all the involved conic pts in this path chunk.	    	  }	  bezcount = 0;	  	  	  //then finally take care of this on-point.	  GLdouble d[12];	  d[0] = (ftOutline.points[ii].x/(64.0*lettersize)+ii*0.0001);	  d[1] = -(ftOutline.points[ii].y/(64.0*lettersize)+ii*0.0001)-w;	  d[2] = 0;	  d[3] = 0;	  //persisPts->push((long)d);	  JTTessVertex(d[0],d[1],0);	  	  if(curContour==ii){	    //persisPts->push(0);	    JTTessNewContour();	    curContourIndex++;	    curContour=ftOutline.contours[curContourIndex];	  }	  	  	  	} else {	  if(ftOutline.tags[ii]!=FT_Curve_Tag_Conic){	    printf("encountered a non-FT_Curve_Tag_Conic\n",0);	  }	  bezaccum[bezcount]=ii;	  bezcount++;	}      }      //one last checl for the chunks            if(bezcount!=0){	//new mutli bez event.		for(int thisB=0;thisB<bezcount;thisB++){	  	  //aligning the points with the function	  int thisp = bezaccum[thisB];//this bez point.	  	  //here is the function.#define BEZIER_STEP_SIZE 0.22	  float bezierValues[2][2];	  float controlPoints[3][2];	  	  controlPoints[1][0] = ftOutline.points[thisp  ].x;	  controlPoints[1][1] = ftOutline.points[thisp  ].y;	  int virtualfirst = ((curContourIndex>0)?(ftOutline.contours[curContourIndex-1]+1):0);	  if (thisp==virtualfirst) {//the one after the last contour's end, or the very first one in the whole array.	    controlPoints[0][0] = ftOutline.points[curContour].x;	    controlPoints[0][1] = ftOutline.points[curContour].y;	    controlPoints[2][0] = ftOutline.points[thisp+1].x;	    controlPoints[2][1] = ftOutline.points[thisp+1].y;	  } else if (thisp==curContour) {	    controlPoints[0][0] = ftOutline.points[thisp-1].x;	    controlPoints[0][1] = ftOutline.points[thisp-1].y;	    controlPoints[2][0] = ftOutline.points[virtualfirst].x;	    controlPoints[2][1] = ftOutline.points[virtualfirst].y;	  } else {	    controlPoints[0][0] = ftOutline.points[thisp-1].x;	    controlPoints[0][1] = ftOutline.points[thisp-1].y;	    controlPoints[2][0] = ftOutline.points[thisp+1].x;	    controlPoints[2][1] = ftOutline.points[thisp+1].y;	  }	  for( unsigned int bi = 0; bi <= ( 1.0f / BEZIER_STEP_SIZE); bi++){	    float t = static_cast<float>(bi) * BEZIER_STEP_SIZE;	    	    	    bezierValues[0][0] = (1.0f - t) * controlPoints[0][0] + t * controlPoints[1][0];	    bezierValues[0][1] = (1.0f - t) * controlPoints[0][1] + t * controlPoints[1][1];	    	    bezierValues[1][0] = (1.0f - t) * controlPoints[1][0] + t * controlPoints[2][0];	    bezierValues[1][1] = (1.0f - t) * controlPoints[1][1] + t * controlPoints[2][1];	    	    bezierValues[0][0] = (1.0f - t) * bezierValues[0][0] + t * bezierValues[1][0];	    bezierValues[0][1] = (1.0f - t) * bezierValues[0][1] + t * bezierValues[1][1];	    	    //AddPoint( bezierValues[0][0], bezierValues[0][1]);	    	    GLdouble d[12];	    d[0] = (bezierValues[0][0]/(64.0*lettersize)+thisp*0.000001);	    d[1] = -(bezierValues[0][1]/(64.0*lettersize))-w;	    d[2] = 0;	    d[3] = 0;	    //persisPts->push((long)d);	    JTTessVertex(d[0],d[1],0);	  }//end of beszier function 	  	  	  /*	    GLdouble d[12];	    d[0] = (ftOutline.points[thisp].x/(64.0*lettersize)+ii*0.0001);	    d[1] = -(ftOutline.points[thisp].y/(64.0*lettersize)+ii*0.0001)-w;	    d[2] = 0;	    d[3] = 0;	    JTTessVertex(d[0],d[1],0);	  */	  	  //add a moveTo	  if(curContour==thisp){	    //persisPts->push(0);	    JTTessNewContour();	    curContourIndex++;	    curContour=ftOutline.contours[curContourIndex];	  }	  //	  	}//end of looping through all the involved conic pts in this path chunk.	      }      bezcount = 0;      //end lasst chunk check          }        //glPopMatrix();                //---------------------now actually draw the processed vertexes.        /*      GLUtesselator*tess = getTessObj();      gluTessBeginPolygon(tess,NULL);      gluTessBeginContour(tess);            for(int ii=0;ii<persisPts->count;ii++){      GLdouble *pi = (GLdouble*)persisPts->get(ii);      if(pi==0){      gluTessEndContour(tess);      //gluTessEndPolygon(tess);      //empty space      //gluTessBeginPolygon(tess,NULL);      gluTessBeginContour(tess);      } else {      gluTessVertex(tess,pi,pi);      }      }      gluTessEndContour(tess);      gluTessEndPolygon(tess);    */            /*      for(int ii=0;ii<persisPts->count;ii++){      GLdouble *pi = (GLdouble*)persisPts->get(ii);      if(pi==0){      JTTessNewContour();      } else {      JTTessVertex(pi[0], pi[0],0);      }      }    */    JTTessEnd();  }    }void JoshFont::drawStringFittedBox(char *inputstr,float right,float bottom){  glPushMatrix();    glScalef((right/getStringWidth(inputstr,1)),(bottom/charHeights['H']),0);  glTranslatef(0,charHeights['H']*2.38,0);  drawString(inputstr,1,0);  glPopMatrix();}void JoshFont::drawString(char *inputstr,float size,float tracking){  glPushMatrix();    glPushMatrix();  glScalef(size,size,0);  //glTranslatef( -(1.0-offx/255.0) , -(1.0-offy/255.0) , 0 );  int lineno = 1;  for(int i=0;i<strlen(inputstr);i++){    if(inputstr[i]==13||inputstr[i]==10){      glPopMatrix();      lineno++;      glTranslatef(0,round(tracking*size),0);      glPushMatrix();      glScalef(size,size,0);    } else {      glPushMatrix();      glTranslatef(charHoriBearingXs[inputstr[i]],		   -(float)charHoriBearingYs[inputstr[i]],0);      this->drawChar(inputstr[i]);      glPopMatrix();            glTranslatef( (float)(charHoriAdvances[inputstr[i]]) ,0,0);    }  }    glPopMatrix();  glPopMatrix();  }void JoshFont::getDrawStringPositions(char *inputstr,float size,float tracking,deque<JPoint> *positions){  JPoint curPos(0,0,0);  //glPushMatrix();  //glScalef(size,size,0);  //glTranslatef( -(1.0-offx/255.0) , -(1.0-offy/255.0) , 0 );  int lineno = 1;  for(int i=0;i<strlen(inputstr);i++){    if(inputstr[i]==13||inputstr[i]==10){      //glPopMatrix();      lineno++;      //glTranslatef(0,round(tracking*size),0);      curPos.x = 0;      curPos.y+=round(tracking*size);      //glPushMatrix();      //glScalef(size,size,0);    } else {      //glPushMatrix();            //glTranslatef(charHoriBearingXs[inputstr[i]],      //       -(float)charHoriBearingYs[inputstr[i]],0);      //this->drawChar(inputstr[i]);      positions->push_back(curPos+JPoint(charHoriBearingXs[inputstr[i]],					 -(float)charHoriBearingYs[inputstr[i]],0));      positions->back()*=size;      //glPopMatrix();            //glTranslatef( (float)(charHoriAdvances[inputstr[i]]) ,0,0);      curPos.x+= (float)(charHoriAdvances[inputstr[i]]);    }  }    //glPopMatrix();  }void JoshFont::drawStringBoxWrap(char *inputstr,float size,float tracking, 				   float right,float bottom,int quickrender){  glPushMatrix();  glTranslatef(0,round(tracking*size)*2,0);  glPushMatrix();  glScalef(size,size,0);    //glTranslatef( -(1.0-offx/255.0) , -(1.0-offy/255.0) , 0 );  int lineno = 1;  float lineadvance = 0;  int line_wordcount=0;  int strln = strlen(inputstr);  for(int i=0;i<strln;i++){    char thisChar = inputstr[i];        //     //calculate the current line size for force-justify spacing per line.    //     float thisFJ = 0;    //     int curPlace = i;    //     int theoretical_line=0;    //     int theoretical_word=0;    //     int wordcount=0;    //     while(1){        //       while(1){    // 	curPlace++;    // 	//break if we got too far.    // 	if(!(curPlace<strln)){    // 	  break;    // 	}    // 	if(inputstr[curPlace]==' '||inputstr[curPlace]=='-'){    // 	  break;    // 	} else {    // 	  theoretical_word += (float)charHoriAdvances[inputstr[curPlace]];    // 	}    //       }    //       wordcount++;    //       if((theoretical_line+theoretical_word)*size>right||curPlace>=strln){    // 	break;    //       } else {    // 	theoretical_line += theoretical_word;    //       }    //     }    //     //now we have the current line. How much longer is the full width of the box?    //     thisFJ = (right-theoretical_line*size)/(float)wordcount;        if(thisChar==13||thisChar==10){      glPopMatrix();      lineno++;      glTranslatef(0,round(tracking*size),0);      glPushMatrix();      glScalef(size,size,0);      lineadvance=0;      line_wordcount=0;    } else {      //calculate the would-be resultant adanvace of the current word.      float theoretical_advance = lineadvance;      int curPlace = i-1;      while(1){	curPlace++;	//break if we got too far.	if(!(curPlace<strln)){	  break;	}	if(inputstr[curPlace]==' '||inputstr[curPlace]=='-'||charHoriAdvances[i] == '\t'){	  break;	} else {	  theoretical_advance += (float)charHoriAdvances[inputstr[curPlace]];	}      }            if( theoretical_advance*size>right && line_wordcount>0  ){//shall we soft-wrap?	glPopMatrix();	lineno++;	glTranslatef(0,round(tracking*size),0);	glPushMatrix();	glScalef(size,size,0);	lineadvance=0;	line_wordcount=0;      }            glPushMatrix();            if(quickrender){	if(thisChar!=' '&&thisChar!='\t'){	  glTranslatef(charHoriBearingXs[thisChar],		       -(float)tracking,0);	  glBegin(GL_LINES);	  glVertex3f(0,0,0);	  glVertex3f(1,1,0);	  glVertex3f(1,0,0);		  glVertex3f(0,1,0);	  glEnd();	}	      } else{	glTranslatef(charHoriBearingXs[thisChar],		     -(float)charHoriBearingYs[thisChar],0);	//glScalef(i*0.05,i*0.05,1);	this->drawChar(inputstr[i]);	if(thisChar==' '||thisChar=='-'||thisChar=='\t'){	  line_wordcount++;	}      }            glPopMatrix();      //       if(thisChar==' '){      // 	glTranslatef( (float)charHoriAdvances[thisChar]+round(thisFJ) ,0,0);      // 	lineadvance+= (float)charHoriAdvances[thisChar]+round(thisFJ);      //       } else {      glTranslatef( (float)charHoriAdvances[thisChar] ,0,0);      lineadvance+= (float)charHoriAdvances[thisChar];      //      }          }  }    glPopMatrix();  glPopMatrix();  }float JoshFont::getStringWidth(char *inputstr,int size){  float strw=0;	  int strln = strlen(inputstr);  for(int i=0;i<strln;i++){    //this->drawChar(inputstr[i]);    if(i==strln-1){      strw+=size*(charWidths[inputstr[i]]+charHoriBearingXs[inputstr[i]]);    } else {      strw+=size*(float)charHoriAdvances[inputstr[i]] ;    }  }  return strw;}int JoshFont::loadBitmapCharRAWFromMemory(void*buffer,				int imageWidth, int imageHeight,				int srcWidth, int srcHeight,int mipmap){  unsigned char *f = (unsigned char*)buffer;  if(buffer==0){    return 0;  }  unsigned char *f_alphad = new unsigned char[imageWidth*imageHeight*4];  int gutter=3;  for(int y=0;y<imageHeight;y++){    for(int x=0;x<imageWidth;x++){      if((x-gutter)<srcWidth&&(y-gutter)<srcHeight && y>=gutter && x>=gutter){	f_alphad[(y)*imageWidth*4+4*(x  )] = 255;	f_alphad[(y)*imageWidth*4+4*(x)+1] = 255;	f_alphad[(y)*imageWidth*4+4*(x)+2] = 255;	f_alphad[(y)*imageWidth*4+4*(x)+3] = f[(y-gutter)*srcWidth+(x-gutter)];//this will differ depending on the ink being used.      } else {	f_alphad[(y)*imageWidth*4+4*(x  )] = 0;	f_alphad[(y)*imageWidth*4+4*(x)+1] = 0;	f_alphad[(y)*imageWidth*4+4*(x)+2] = 0;	f_alphad[(y)*imageWidth*4+4*(x)+3] = 0;      }    }  }  GLuint  t;  glGenTextures(1,&t);  glBindTexture(GL_TEXTURE_2D, t);  glTexParameteri(GL_TEXTURE_2D, GL_TEXTURE_MAG_FILTER, GL_LINEAR);    if(mipmap){    glTexParameteri(GL_TEXTURE_2D, GL_TEXTURE_MIN_FILTER, GL_LINEAR_MIPMAP_LINEAR);    gluBuild2DMipmaps( GL_TEXTURE_2D, 4, imageWidth,imageHeight,GL_RGBA, GL_UNSIGNED_BYTE, f_alphad );  }else{    glTexParameteri(GL_TEXTURE_2D, GL_TEXTURE_MIN_FILTER, GL_LINEAR);  }      glTexParameteri(GL_TEXTURE_2D, GL_TEXTURE_WRAP_S, GL_CLAMP);  glTexParameteri(GL_TEXTURE_2D, GL_TEXTURE_WRAP_T, GL_CLAMP);  //glTexParameteri(GL_TEXTURE_2D, GL_TEXTURE_WRAP_R, GL_CLAMP);  glTexImage2D(GL_TEXTURE_2D,	       0,4, imageWidth, imageHeight, 0,	       GL_RGBA,	       GL_UNSIGNED_BYTE,	       f_alphad);  //#if defined(__DARWIN__)  delete f_alphad;  //delete f;  //#endif  return t;}float JoshFont::randomFloat(){  return ((float)rand())/((float)RAND_MAX);}