#ifndef __JTTOOLKIT__#define __JTTOOLKIT__#define DEFAULT_MOUSEX 695#define DEFAULT_MOUSEY 457#include <math.h>#include <time.h>#include <stdlib.h>#if defined(__DARWIN__)#include "png.h"#elif defined(linux)#include <png.h>#else#define NOMINMAX#include <windows.h>#include <png.h>//#endif#define PI 3.141592653#include "gl_et_al.h"#include <iostream.h>#include <fstream.h> //#include "Vector.h"//#include <fmod.h>//#include <fmod_errors.h>#include "project.h"#include <string.h>#include "quadstretch.h"#include "JoshFont.h"#include "JPoint.h"#include <sys/ioctl.h>#include <sys/stat.h>#include <fcntl.h>#include <stdio.h>#include <unistd.h>#include <stdlib.h>#include <sched.h>#include <pthread.h>#include <sys/types.h>#include <sys/socket.h>#include <netinet/in.h>#include <arpa/inet.h>#include <stdio.h>#include <stdlib.h>#include <sched.h>#include <string.h>#include <unistd.h>#include <netdb.h>/**   limited set of Processing API-completion features for easy   brain-porting from Processing to C++. This toolkit is intended as a   halfway house between Processing and the wider scope of   applications that can be authored in C and C++. The namespace has   evolved with me for almost a decade, having originally gotten its   start as a GLUT callback helloworld - an ACU strain. The template   has been used for past projects in a few universities and   companies. The template is familyware.      @author jtnimoy   */namespace jttoolkit{      #if defined(__DARWIN__)#define KEY_BACKSPACE 65#else#define KEY_BACKSPACE 8#endif#define KEY_DELETE 127        //------------ user event prototypes ------------------------------  /**     global, static, procedural way to populate a jttoolkit template. setup already     instantiates a copy of Global. Consider the new way - which is     populating Global::Global()  */    void setup();  void stop(); /**<     stops the program  */    /**     global, static, procedural way to populate a jttoolkit template's     p5-draw() equiv. loop is already stepping the Global::loop()     function. Please consider using that for your global stepping     needs.  */    void loop();  /**     global static procedural way to catch a window resizing event.     Consider populating the Global object instead.  */  void jttoolkit_windowReshaped(int winX,int winY,int w,int h);    /**     global, static, procedural way to catch a keyDown event. Consider     populating the Global object instead  */  void jttoolkit_keyDown(int key,int special);  /**     global, static, procedural way to catch a keyUp event. Consider     populating the Global object instead  */    void jttoolkit_keyUp(int key,int special);    /**     global, static, procedural way to catch a mouseDown     event. Consider populating the Global object instead  */      void jttoolkit_mouseDown();    /**     global, static, procedural way to catch a mouseUp event. Consider     populating the Global object instead  */      void jttoolkit_mouseUp();    // ----------------- user tool function prototypes ------------------------    extern "C"{        int main(int ,char**);  ///< the app's main entrypoint. at this point abstracted away by a couple layers of setup.       char* trimLeft(char*buff); ///< basic string manipulation function. totally out of place :)       void drawUnitSquare();  ///< do a glRectf(0,0,1,1)       void drawUnitSquareSlightlySmaller();  ///< do a glRectf(0.01,0.01,0.99,0.99) - good for avoiding texture-bleed       void viewPerspective(float angle); ///< change lense angle value       void viewOrtho(); ///< don't use any perspective skewing - just render orthogonally.       void roundedRect(int gl_style,float x1,float y1,float x2,float y2,float radius,int steps);   ///< draw a rounded rectable        int jttoolkit_init();  ///< an internal jttoolkit function       void toggleFullScreen();   ///< toggle fullscreen mode.       void exportPostscript(char *filename);  ///< export a vector-based screenshot using gl2ps.       void fileFromString( char *fname, char *data, long datasize);  ///< writes the bytes in null-terminated data string to file fname.       unsigned char* stringFromFile(char *fname);   ///< returns a file pointer to the contents of the file. when you are done using this string, free it using free(ptr);       long getFileSize( char *fname); ///< returns the size of a file in bytes.    void getFile( char *filename, unsigned char *buff, int length); ///< gets the contents of a file and stores it into a string.    void hideMouse();///< hides the mouse    void showMouse();///< shows the mouse    int buildScreenFont(char *fontName,int size); ///< loads a font and returns the ID    void drawScreenFont(int fontID,char*text,int tracking); ///< draws the font to the screen as text    void killScreenFont(int fontID); ///< unloads the fontID (i've never needed to call this)    float rndScale(float scalar);///< return a random float between -0.5 and 0.5    JPoint rndPt(float); ///< return a random JPoint between [-0.5,-0.5,-0.5] and [0.5,0.5,0.5]    float rndLerp(float a,float b); ///< give me a random place between a and b    float randomFloat(); ///< give me a random number between 0 and 1    void lights(); ///< enables GL lighting (defaultly off)    void nolights(); ///< disables GL lighting    float getDist(float x1,float y1,float x2,float y2);  ///< find the 2D distance between 2 points       void polar2rect(double r,double theta,double returnPair[2]);  ///< convert from polar to cartesian space       void rect2polar(double x,double y,double returnPair[2]);  ///< convert from cartesian to polar space       void line(JPoint p1,JPoint p2);     ///< draw a line from one JPoint to another.           /**       new JPoint-friendly bezier renderer - Use it!       @param p1 first point       @param p2 first handle       @param p3 second handle       @param p4 second point       @param steps line segment resolution    */    void bezier(JPoint p1,JPoint p2,JPoint p3,JPoint p4,int steps);            /**       generate some bezier data, without any JPoint in the code or glRendering    */    void interpolateBezier(float P0X,float P0Y,float P0Z,			   float P1X,float P1Y,float P1Z,			   float P2X,float P2Y,float P2Z,			   float P3X,float P3Y,float P3Z,			   int segs,float Xs[],float Ys[],float Zs[]);            png_bytep* make_pixels(int width, int height) ;  ///< allocates new storage for an 8-bit image of the specified dimensions           //removed when i went to imagemagick    //void saveScreenToTGAFile(char *filename);    //void init_saveScreen();            static unsigned char*rawpixels = NULL; ///< a persistent buffer for rapid-fire calls to saveScreen. Also a global static. So ignore.            //ColorRGB getScreenPixel(int x,int y);///< returns the color value on the window at a given X Y pixel position.        /**       save the screen to a file. filename format guidelines goverened       by Magick++ Image object. Gabe, isn't there a saveScreenRGB and       saveScreenRGBA together somewhere?    */        //void saveScreen(char *filename);                 //------------------------ internal prototypes-------------------------------            void display();  ///< glut callback function that babysits the glut window       void idle();  ///< glut idle callback function that babysits nothing in particular at the moment.       void timerFunc(int v);  ///< glut idle callback function that babysits the calls to jttoolkit::loop() and hence Global::loop()       void keyboardDown(unsigned char k,int x,int y); ///< glut keyboard event callback       void keyboardUp  (unsigned char k,int x, int y); ///< glut keyboard event callback       void specialFunc(int k, int x,int y); ///< glut keyboard event callback       void mouseMotionFunc(int x, int y); ///< glut mouse event callback       void mousePassiveMotionFunc(int x, int y); ///< glut mouse event callback       void mouseFunc(int state, int button, int x, int y);  ///< glut mouse event callback       /**       glut window callback function that catches the window resizing       events and adjusts the canned returns of width() and height()    */    void reshape(int w,int h);        void _draw_single_screenFont(int fontID, char*text);  ///< this is a mystery one. someone please call it and tell me what it did.       void _execute_frame(); ///< an internal bridge function between glut timer callback and jttoolkit::loop(), then on to Global::loop()     };    //----------------- useful globals for high level programmers -----------------    static unsigned long _ticks = 0; ///< internal storage, don't reference in code - in fear of bugs. So ignore this.  int ticks(); ///< how many frames have elapsed in the simulation? ticks is like millis in Processing    static unsigned long _width = 0;  ///< internal storage, don't reference in code - in fear of bugs. So ignore this.  int width(); ///< get the stage height.    static unsigned long _height = 0;   ///< internal storage, don't reference in code - in fear of bugs. So ignore this.  int height(); ///< get the stage height      void ignoreMouse(int state);  ///< whether or not the real mouse is being ignored by the mouse event system  static int _ignoreMouse = 0;  ///< internal storage, don't reference in code - in fear of bugs. So ignore this.    static unsigned long _mouseX = DEFAULT_MOUSEX; ///< internal storage, don't reference in code - in fear of bugs. So ignore this.  int mouseX();  ///< return the position of the mouse relative to the stage (not the screen)  @see setMouseX  void setMouseX(long);  ///< move the mouseX to some new location.  @see mouseY    static unsigned long _mouseY = DEFAULT_MOUSEY;  ///< internal storage, don't reference in code - in fear of bugs. So ignore this.  int mouseY();  ///< return the position of the mouse relative to the stage (not the screen)  void setMouseY(long);   ///< move the mouseY to some new location. @see mouseY    static float _friction = 0.99997f;  ///< internal storage, don't reference in code - in fear of bugs. So ignore this.  float friction();  ///< return the global friction value, which apparently has been superceded by the JMass::friction :-)  void setFriction(float f);   ///< alter the global friction value, which apparently has been superceded by the JMass::friction :-) @see friction    static float _frequencyRange = 50000;   ///< internal storage, don't reference in code - in fear of bugs. So ignore this.  float frequencyRange();  ///< get the global frequency range. I suppose this is also some unused global member from back in the day when the toolkit was still trying to blah blah blah.  void setFrequencyRange(float f); ///< get the global frequency range. @see frequencyRange      //tess    /// adding tesselation functionality#if defined(__DARWIN__)#define JTTESSCALLBACK#else#define JTTESSCALLBACK __stdcall#endif  #define TESSCACHE_NEWCONTOUR 1    /// some tesselation globals. ignore.  static GLdouble **tesscache;  //static Vector*tessfreemem=0;  static int tessPtr = 0;  ///< internal storage, don't reference in code - in fear of bugs. So ignore this.  static int tessmax = 0;  ///< internal storage, don't reference in code - in fear of bugs. So ignore this.  static int tessBase = 0;   ///< internal storage, don't reference in code - in fear of bugs. So ignore this.  static GLUtesselator* tobj=0;  ///< internal storage, don't reference in code - in fear of bugs. So ignore this.      /**     start the glu tesselation engine.     @see JTTessBegin     @see JTTessVertex     @see JTTessNewContour     @see JTTessEnd     @see JTTessErrorCheck  */  void JTTessInit(int memsize);   void JTTessBegin(); ///< call this function before starting to render out a tesselated path @see JTTessEnd  void JTTessVertex(float x,float y, float z); ///< lay down a vertex - similar to glVertex, but for this system instead  void JTTessNewContour(); ///< call this to make a break in the path and start a new shape.  void JTTessEnd(); ///< @see JTTessBegin  void doTessErrorCheck();///< print a bad msg if we need to    void _tessBind(); ///< an internal glu tesselation helper function. Safely ignore.    /**     internally used callbacks for glu tesselation API. See higher level jttoolkit functions.     @see JTTessInit  */    void JTTESSCALLBACK JTTess_combineCallback(GLdouble coords[3], 					     GLdouble *vertex_data[4],					     GLfloat weight[4], GLdouble **dataOut );        void JTTESSCALLBACK JTTess_vertexCallback(GLvoid *vertex); ///< internally used callbacks for glu tesselation API. See higher level jttoolkit functions. @see JTTessInit  void JTTESSCALLBACK JTTess_errorCallback(GLenum errorCode); ///< internally used callbacks for glu tesselation API. See higher level jttoolkit functions. @see JTTessInit  void JTTESSCALLBACK JTTess_endCallback(void); ///< internally used callbacks for glu tesselation API. See higher level jttoolkit functions. @see JTTessInit  void JTTESSCALLBACK JTTess_beginCallback(GLenum which); ///< internally used callbacks for glu tesselation API. See higher level jttoolkit functions. @see JTTessInit      //-----------------internal globals--------------------------------------------    static int firstloop=1; ///< internal storage, don't reference in code - in fear of bugs. So ignore this.  static unsigned long frameRate = 30; ///< internal storage, don't reference in code - in fear of bugs. So ignore this.  void jt_frameRate(unsigned long f); ///< this is misleading. it's actually the pause time in milliseconds.  static char drawScreenFont_buff[1024*256];///< text max - internal storage, don't reference in code - in fear of bugs. So ignore this.  static int lastGlutFrameTime=0;///< internal storage, don't reference in code - in fear of bugs. So ignore this.  static unsigned char *drawbuffer; ///< internal storage, don't reference in code - in fear of bugs. So ignore this.  static int fullscreenmode = 0; ///< internal storage, don't reference in code - in fear of bugs. So ignore this.    void jt_resizeDrawBuffer();  #if defined(__DARWIN__)  //MAC CLASSIC#elif defined(linux)#else  //WINDOWS  static HWND theHwnd=0;  ///< the HWND of the glut window. static global, so ignore.#endif    static JoshFont *font; ///< the HWND of the glut window. static global, so ignore.  JoshFont *getFont(); ///< returns a pointer to the ready-instanced JoshFont, starring media/usethis.ttf  JPoint mouse();///< returns a stack-allocated JPoint instance, with the mouse coordinates in it.    void stopDemo(); ///< i can't remember what that was - please ignore.  void loadByNumber(int num); ///< hmm, maybe this is just old DNA from another project - please ignore.    void ignored_mouseMove(int x,int y);  ///< a place to catch user events, even if the mouse facilities have been shut off.  void ignored_mouseDown(int x,int y); ///< a place to catch user events, even if the mouse facilities have been shut off.  void ignored_mouseUp(int x,int y); ///< a place to catch user events, even if the mouse facilities have been shut off.          //-----------------------------------------------------------------------------};using namespace jttoolkit;//everyone who includes this header should automatically gain access into the namespace.#endif