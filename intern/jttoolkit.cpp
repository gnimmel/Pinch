#include "jttoolkit.h"#include <stdio.h>#include <stdlib.h>#include <string.h>#include <iostream.h> #include <fstream.h>#define INIT_WINDOW_X 0#define INIT_WINDOW_Y 0#define INIT_WINDOW_WIDTH 900#define INIT_WINDOW_HEIGHT 600//#include "gl2ps.h"#if defined (__DARWIN__)#include <ApplicationServices/ApplicationServices.h>#endif#define use_perspective#define VERBOSE 0//turn this on and off for speed//---- user-global access functionsnamespace jttoolkit{  int ticks(){return _ticks;}  int width(){return _width;}  int height(){return _height;}    int mouseX(){return _mouseX;}  int mouseY(){return _mouseY;}        void setMouseX(long xx){_mouseX = xx;}  void setMouseY(long yy){_mouseY = yy;}    void ignoreMouse(int state){_ignoreMouse = state;}    //--------------    void *threadFunc(void*stuff){  }    //------------------------------------------------------------------------  void initfmod(){    /*  	if (FSOUND_GetVersion() < FMOD_VERSION){	printf("Error : You are using the wrong DLL version!  You should be using FMOD %.02f\n", FMOD_VERSION);	exit(1);	}		if(!FSOUND_Init(48000, 1024, FSOUND_INIT_GLOBALFOCUS)){	printf("%s\n",FMOD_ErrorString(FSOUND_GetError()));	}    */  }  //------------------------------------------------------------------------        float friction(){return _friction;}  void setFriction(float f){_friction = f;}    float frequencyRange(){return _frequencyRange;}  void setFrequencyRange(float f){_frequencyRange = f;}    void drawUnitSquare(){    glBegin(GL_QUADS);    glTexCoord2f(0,0);glVertex2f(0,0);	    glTexCoord2f(1,0);glVertex2f(1,0);    glTexCoord2f(1,1);glVertex2f(1,1);    glTexCoord2f(0,1);glVertex2f(0,1);    glEnd();  }      void  drawUnitSquareSlightlySmaller(){    glBegin(GL_QUADS);    glTexCoord2f(0.01,0.01);glVertex2f(0,0);	    glTexCoord2f(0.99,0.01);glVertex2f(1,0);    glTexCoord2f(0.99,0.99);glVertex2f(1,1);    glTexCoord2f(0.01,0.99);glVertex2f(0,1);    glEnd();  }          void toggleFullScreen(){    fullscreenmode=!fullscreenmode;    if(fullscreenmode){      glutFullScreen();    } else {      glutReshapeWindow(INIT_WINDOW_WIDTH,INIT_WINDOW_HEIGHT);      glutPositionWindow(0,10);    }  }    char* trimLeft(char*buff){    //count how many to offset backward    int whiteCount = 0;    for(int i=0;i<strlen(buff);i++){      if(buff[i]==' '||buff[i]=='\r'||buff[i]=='\n'||buff[i]=='\t'){	whiteCount++;      }else{	break;      }    }    if(whiteCount>0){      for(int b=0;b<strlen(buff)-whiteCount;b++){	buff[b] = buff[b+whiteCount];      }    }    return buff;  }    void fileFromString(unsigned char *fname, char *data, long datasize){    long i=0;    FILE *fp = fopen((const char*)fname,"wb");    for(i=0;i<datasize;i++){      fputc(data[i],fp);    }    fclose(fp);  }      //--------------------------------------------------------------------      unsigned char* stringFromFile(char *fname){    long fsize;    unsigned char *a;        if(fname==NULL){      if(VERBOSE)printf("err: stringFromFile: filename was null\n",NULL);      return 0;    }    fsize = getFileSize(fname);        if(fsize==0){      if(VERBOSE)printf("err: stringFromFile: file size was zero\n",NULL);      return 0;    }    a = new unsigned char[fsize+1];        if(a==NULL){      if(VERBOSE)printf("err: stringFromFile: memory allocation failed\n",NULL);      return 0;    }        getFile((char*)fname,a,fsize);    a[fsize]=0;    return a;  }      //--------------------------------------------------------------------    long getFileSize( char *fname){    FILE *fp;    long fsize;    if (fname == NULL){      if(VERBOSE)printf("err: getFileSize: filename was null\n",NULL);      return 0;    }    fp = fopen((const char*)fname, "rb");    if (fp == NULL){      if(VERBOSE)printf("err: getFileSize: file stream failed\n",NULL);      return 0;    }    if(fseek(fp, 0, SEEK_END)!=0){      if(VERBOSE)printf("err: getFileSize: fseek failed\n",NULL);    }    fsize = ftell(fp);    fclose(fp);    return fsize;  }      //--------------------------------------------------------------------    void getFile( char *filename, unsigned char *buff, int length){    unsigned char c=0;    long buffcnt=0;    long i=0;    ifstream f;    //#if defined(__DARWIN__)    //	f.open(filename);    //#else    f.open((const char*)filename, ios::binary);    //#endif    f.read((char*)buff, length);    //for(i=0;i<length;i++){    //	printf("{%c}",buff[i]);    //}    f.close();  }      //--------------------------------------------------------------------    void hideMouse(){    #if defined(__DARWIN__)    //MAC    HideCursor();#elif defined(linux)    //LINUX    //ignore#else    //WINDOWS    ShowCursor(FALSE);#endif          }    //--------------------------------------------------------------------    void showMouse(){#if defined(__DARWIN__)    //MAC    ShowCursor();#elif defined(linux)    //ignore#else    //WINDOWS    ShowCursor(TRUE);#endif  }    void display(){}  void display2(){}    void _execute_frame(){    glClear(GL_COLOR_BUFFER_BIT|GL_DEPTH_BUFFER_BIT);    glPushMatrix();#if defined(use_perspective)    glTranslatef(-width()/2.0f,height()/2.0,-height()/2.0);    glScalef(1,-1,1);#endif     if(firstloop){//first time!      firstloop = false;      font = new JoshFont("media/usethis.ttf",160,JF_BITMAP,true,true);      glBlendFunc(GL_SRC_ALPHA, GL_ONE_MINUS_SRC_ALPHA);      setup();    }else{      loop();      //glFlush();      //glutPostRedisplay();      _ticks++;    }    glPopMatrix();    glutSwapBuffers();      }    void idle(){    /*      if(glutGet(GLUT_ELAPSED_TIME) - lastGlutFrameTime > frameRate){      _execute_frame();      lastGlutFrameTime = glutGet(GLUT_ELAPSED_TIME);      }    */  }      void timerFunc(int v) {    //if(glutGet(GLUT_ELAPSED_TIME) - lastGlutFrameTime > frameRate){    _execute_frame();    //}    glutTimerFunc(frameRate,timerFunc,0);  }    void preKeyDown(unsigned char k, int special){    if(special){      if(k==11){	toggleFullScreen();      }    } else {      //non special      if(k==27){	//exit(0);      }else if (k==KEY_DELETE || k==KEY_BACKSPACE){		      } else if (k==6){//ctrl+f on a mac	toggleFullScreen();      } else {	      }    }      }    void keyboardDown(unsigned char k,int x,int y){    if(!_ignoreMouse){      _mouseX=x;      _mouseY=y;    }    preKeyDown(k,0);    jttoolkit_keyDown(k,0);  }    void keyboardUp(unsigned char k,int x,int y){    if(!_ignoreMouse){      _mouseX=x;      _mouseY=y;    }    //printf("keyboardUp: %c %i\n",k);    jttoolkit_keyUp(k,0);  }      void specialFunc(int k,int x,int y){    if(!_ignoreMouse){      _mouseX=x;      _mouseY=y;    }    preKeyDown(k,1);    jttoolkit_keyDown(k,1);  }    void mouseMotionFunc(int x, int y){    if(!_ignoreMouse){      _mouseX=x;      _mouseY=y;    }else{      ignored_mouseMove(x,y);    }      }    void mousePassiveMotionFunc(int x, int y){    if(!_ignoreMouse){      _mouseX=x;      _mouseY=y;    }else{      ignored_mouseMove(x,y);    }    //  printf("%i %i\n",_mouseX,_mouseY);  }    void mouseFunc(int button, int state, int x, int y){    if(!_ignoreMouse){      _mouseX=x;      _mouseY=y;            if(state==GLUT_DOWN){	jttoolkit_mouseDown();      } else {	jttoolkit_mouseUp();      }          }else{            if(state==GLUT_DOWN){	ignored_mouseDown(x,y);      } else {	ignored_mouseUp(x,y);      }          }  }    void viewPerspective(float angle){    glMatrixMode(GL_PROJECTION);    glLoadIdentity();    gluPerspective(angle,(float)width()/(float)height(),0.0001,10000);    //glFrustum(-2, 2, -2, 2, 1.0f, 100.0f);    glMatrixMode(GL_MODELVIEW);  }      void viewOrtho(){    glMatrixMode(GL_PROJECTION);    glLoadIdentity();    glOrtho(0,width(),-height(),0,-10000,10000);    glMatrixMode(GL_MODELVIEW);  }    void reshape(int w,int h){    //  if(glutGetWindow()==MainWindowID){    if(1){            _width = w;      _height = h;      //	to keep it propertional & let the window stretch      //	glMatrixMode(GL_PROJECTION);      //	glLoadIdentity();      glViewport(0,0,w,h);      //	if(w<h){      //		float r = ((float)h/(float)w);      //		glOrtho(-1,1,-r,r,-2,2);      //	}else{      float r = ((float)w/(float)h);      //		glOrtho(-r,r,-1,1,-2,2);      //	}      //	this->draw();            viewPerspective(90);      glLoadIdentity();          } else { //then i can assume for now that it was the output console window.            glViewport(0,0,w,h);      float r = ((float)w/(float)h);            glMatrixMode(GL_PROJECTION);      glLoadIdentity();            //#if defined(use_perspective)      //gluPerspective(90,(float)w/(float)h,0.0001,10000);      //#else      glOrtho(0,w,h,0,-10000,10000);      //#endif      //glFrustum(-2, 2, -2, 2, 1.0f, 100.0f);            glMatrixMode(GL_MODELVIEW);      glLoadIdentity();    }    //  jt_resizeDrawBuffer();    int winX = glutGet(GLUT_WINDOW_X);    int winY = glutGet(GLUT_WINDOW_Y);    jttoolkit_windowReshaped(winX,winY,w,h);  }    void jt_resizeDrawBuffer(){    //  delete [] drawbuffer;    //  drawbuffer = new unsigned char[width()*height()*4];  }    int main(int argc,char** argv){            glutInit(&argc,argv);    glutInitDisplayMode (GLUT_DOUBLE|GLUT_RGBA);    glutInitWindowSize (INIT_WINDOW_WIDTH,INIT_WINDOW_HEIGHT);    glutInitWindowPosition (INIT_WINDOW_X,INIT_WINDOW_Y);        int gameMode = 0;    if(argc>1){      for(int i=0;i<strlen(argv[1]);i++){	switch(argv[1][i]){	case 'g':	  gameMode = true;	}      }    }        if(gameMode){      glutGameModeString("1440x900:16@60");      glutEnterGameMode();    }else{      glutCreateWindow (" ");    }        jttoolkit_init();    //toggleFullScreen();    glutMainLoop();        //do we ever even get here?    //FSOUND_Close();    stop();    exit(0);    return 0;  }    int jttoolkit_init(){    glutIdleFunc(idle);    glutDisplayFunc(display);    glutReshapeFunc(reshape);    glutMouseFunc(mouseFunc);    glutMotionFunc(mouseMotionFunc);    glutPassiveMotionFunc(mousePassiveMotionFunc);    glutKeyboardFunc (keyboardDown);    glutKeyboardUpFunc (keyboardUp);    glutSpecialFunc (specialFunc);    glutTimerFunc(frameRate,timerFunc,0);        // a whole bunch of switches for the openGL engine    glEnable(GL_TEXTURE_2D);    glEnable(GL_BLEND);    glEnable(GL_DEPTH_TEST);    //glBlendFunc(GL_SRC_ALPHA, GL_ONE_MINUS_SRC_COLOR);    //glEnable(GL_LINE_SMOOTH);    //glEnable(GL_POLYGON_SMOOTH);    glLineWidth(1);    //  glDepthFunc(GL_LESS);//was GL_LEQUAL    glDepthFunc(GL_LEQUAL);//was GL_LEQUAL    glClearDepth(1.0f);    glDisable(GL_DITHER);    //glShadeModel(GL_SMOOTH);    glMatrixMode(GL_PROJECTION);	//	 The Projection Matrix    glLoadIdentity();			// The Projection Matrix    // Calculate The Aspect Ratio Of The Window    //gluPerspective(45.0f,(float)wW/(float)wH,0.1f,100.0f);    //gluLookAt(0,0,1,0,0,0,0,1,0);    glMatrixMode(GL_MODELVIEW); // The Modelview Matrix    glLoadIdentity();    // The Modelview Matrix    //glHint(GL_PERSPECTIVE_CORRECTION_HINT, GL_NICEST);	// Perspective Calculations    //glEnable(GL_FOG);    //glFogf(GL_FOG_START,-100);    //glFogf(GL_FOG_END,-200);    //glFogf(GL_FOG_DENSITY,0.1);    //float r[] = {0.5,0.5,0.5,0.5};    //glFogfv(GL_FOG_COLOR,r);    //--------------------------------------------------------------------------------    glClearColor(0,0,0,0);    //also, if that doesn't work,  check if the users screen is 640x48, then fullscreen the game.    //#if defined(__DARWIN__)    //problem with fullscreen - it disables the glut passive motion func.    //#else    //if(fullscreenmode)glutFullScreen();    //#endif      }    int buildScreenFont(char *fontName, int size){    return 0;  }      void _draw_single_screenFont(int fontID, char*text){        glCallLists(strlen(text), GL_UNSIGNED_BYTE, text);      }    void drawScreenFont(int fontID, char*text,int tracking){    int i;    int drawScreenFont_buffpt=0;    int lineCounter=0;    if (text == NULL)return;    glPushAttrib(GL_LIST_BIT);    glRasterPos3f(0,lineCounter,0);    glListBase(fontID);    for(i=0;i<strlen(text);i++){      if(text[i]=='\n'){	drawScreenFont_buff[drawScreenFont_buffpt]=0;	_draw_single_screenFont(fontID,drawScreenFont_buff);	lineCounter+=tracking;	glRasterPos3f(0,lineCounter,0);	drawScreenFont_buffpt=0;      }else{	drawScreenFont_buff[drawScreenFont_buffpt] = text[i];	drawScreenFont_buffpt++;      }    }    drawScreenFont_buff[drawScreenFont_buffpt]=0;    _draw_single_screenFont(fontID,drawScreenFont_buff);    glPopAttrib();  }      void killScreenFont(int fontID){    glDeleteLists(fontID,256);  }      void lights(){    glEnable(GL_LIGHT0);    glEnable(GL_LIGHTING);    glEnable(GL_COLOR_MATERIAL);  }        void nolights(){    glDisable(GL_LIGHT0);    glDisable(GL_LIGHTING);    glDisable(GL_COLOR_MATERIAL);  }      float rndScale(float scalar){    return (randomFloat()-0.5)*scalar;  }      JPoint rndPt(float s){    return JPoint(rndScale(s),rndScale(s),rndScale(s) );  }    float rndLerp(float a,float b){    return a+(b-a)*randomFloat();  }    float randomFloat(){    return ((float)rand())/((float)RAND_MAX);  }    void line(JPoint p1,JPoint p2){    glBegin(GL_LINES);    p1.glVertex();    p2.glVertex();    glEnd();  }    void bezier(JPoint p1,JPoint p2,JPoint p3,JPoint p4,int steps){    float *Xs = new float[steps];    float *Ys = new float[steps];    float *Zs = new float[steps];            interpolateBezier(		      p1.x,p1.y,p1.z,		      p2.x,p2.y,p2.z,		      p3.x,p3.y,p3.z,		      p4.x,p4.y,p4.z,		      steps,Xs,Ys,Zs) ;        glBegin(GL_LINE_STRIP);    p1.glVertex();    for(int i=1;i<steps-1;i++){      glVertex3f(Xs[i],Ys[i],Zs[i]);    }    p4.glVertex();    glEnd();        delete Xs;    delete Ys;    delete Zs;      }      void interpolateBezier(			 float P0X,float P0Y,float P0Z,			 float P1X,float P1Y,float P1Z,			 float P2X,float P2Y,float P2Z,			 float P3X,float P3Y,float P3Z,			 int segs,			 float Xs[] , float Ys[] , float Zs[]) {        float t=0.0f,dt=1.0f/(float)(segs-1);		// calculating increment    float Q0X,Q0Y,Q0Z;    float Q1X,Q1Y,Q1Z;    float Q2X,Q2Y,Q2Z;    float R0X,R0Y,R0Z;    float R1X,R1Y,R1Z;    float x;float y;float z;    float xx=P0X;float yy=P0Y;float zz=P0Z;    for (int i=0;i<segs;i++) {      Q0X = P0X + t*(P1X-P0X); Q0Y = P0Y + t*(P1Y-P0Y); Q0Z = P0Z + t*(P1Z-P0Z);      Q1X = P1X + t*(P2X-P1X); Q1Y = P1Y + t*(P2Y-P1Y); Q1Z = P1Z + t*(P2Z-P1Z);      Q2X = P2X + t*(P3X-P2X); Q2Y = P2Y + t*(P3Y-P2Y); Q2Z = P2Z + t*(P3Z-P2Z);      R0X = Q0X + t*(Q1X-Q0X); R0Y = Q0Y + t*(Q1Y-Q0Y); R0Z = Q0Z + t*(Q1Z-Q0Z);      R1X = Q1X + t*(Q2X-Q1X); R1Y = Q1Y + t*(Q2Y-Q1Y); R1Z = Q1Z + t*(Q2Z-Q1Z);      x = R0X + t*(R1X-R0X);      y = R0Y + t*(R1Y-R0Y);      z = R0Z + t*(R1Z-R0Z);      //drawLine(xx,yy,zz,x,y,z);      Xs[i]=x;      Ys[i]=y;      Zs[i]=z;      xx=x;      yy=y;      zz=z;      t+=dt;    }  }      float absf(float a){    if(a<0)return -a;    return a;  }      float getDist(float x1,float y1,float x2,float y2){    double x = absf(x1-x2);    double y = absf(y1-y2);    x=x*x;    y=y*y;    return (float)sqrt(x+y);  }      void rect2polar(double x,double y,double returnPair[2]){    returnPair[0] = getDist(0.0,0.0,x,y);    returnPair[1] = atan2(y,x);  }    void polar2rect(double r,double theta,double returnPair[2]){    returnPair[0] = r*cos(theta);    returnPair[1] = r*sin(theta);  }        //tess    void JTTessVertex(float x,float y, float z){    //first look for available memory before allocating more.    //printf("%f %f %f\n",x,y,z);    doTessErrorCheck();    //printf("1 %i\n",tessPtr);    GLdouble *p = tesscache[tessBase+tessPtr];    //printf("2\n",0);    tessPtr++;        p[0] = x;    p[1] = y;    p[2] = z;    p[3] = 0;    //printf("3\n",0);    //if(tesscache!=0)tesscache->push((long)p);  }      void JTTessEnd(){    //FLUSH IT!        tobj = gluNewTess();    _tessBind();        if(tesscache!=0){      gluTessBeginPolygon(tobj,NULL);      gluTessBeginContour(tobj);            for(int i=tessBase;i<tessBase+tessPtr;i++){	GLdouble*t = tesscache[i];	if((long)t==TESSCACHE_NEWCONTOUR){	  gluTessEndContour(tobj);	  gluTessBeginContour(tobj);	} else {	  GLdouble *g = (GLdouble*)t;	  gluTessVertex(tobj,g,g);	}      }            gluTessEndContour(tobj);      gluTessEndPolygon(tobj);    }    gluDeleteTess(tobj);    glFlush();    //JTTessBegin();//reset to new.      }      /*    void JTTessInit(int memsize){    tessfreemem = new Vector();    tesscache = new GLdouble*[memsize];    tessmax = memsize;    for(int i=0;i<memsize;i++){    tesscache[i] = new GLdouble[12];    }    }  */        void JTTessNewContour(){    doTessErrorCheck();    tesscache[tessBase+tessPtr] = (GLdouble*)TESSCACHE_NEWCONTOUR;    tessPtr++;      }      void JTTessBegin(){    /*      if(tesscache!=0){      //     for(int i=0;i<tesscache->count ;i++){      //       long t = tesscache->get(i);      //       switch(t){      //       case TESSCACHE_NEWCONTOUR:break;      //       default:      //printf("%i\n",t);      //printf("%i\n",((GLdouble*)(t))[0]);      //delete [] (GLdouble*)t;//i'm leaving this all in memory, but it's dangerous!      //tessfreemem->push(t);      //break;      //      }      //}      //delete tesscache;      //tesscache = new Vector();            } else { //it WAS zero.      //tesscache = new Vector();      }      tessBase += tessPtr;//advance forward.      tessPtr = 0;    */  }      void doTessErrorCheck(){    if(tessPtr+tessBase>tessmax){      printf("error:not enough memory allocated to JTTess",0);      exit(0);    }  }        void _tessBind(){          //#if defined (__DARWIN__)    //#define TESSTYPE (GLvoid (*)(...))    //#else    //typedef GLvoid ( *GluTessCallbackType)(...);    //#define TESSTYPE reinterpret_cast<GluTessCallbackType>    //#endif    /*          gluTessCallback(tobj, GLU_TESS_VERTEX,    TESSTYPE(glVertex3dv));    gluTessCallback(tobj, GLU_TESS_BEGIN,    TESSTYPE(JTTess_beginCallback));    gluTessCallback(tobj, GLU_TESS_END,    TESSTYPE(&JTTess_endCallback));    gluTessCallback(tobj, GLU_TESS_ERROR,    TESSTYPE(JTTess_errorCallback));    gluTessCallback(tobj, GLU_TESS_COMBINE,    TESSTYPE(JTTess_combineCallback));      gluTessProperty(tobj, GLU_TESS_WINDING_RULE,    GLU_TESS_WINDING_POSITIVE);    */  }      /*  the callback routines registered by gluTessCallback() */      void JTTESSCALLBACK JTTess_combineCallback(GLdouble coords[3], 					     GLdouble *vertex_data[4],					     GLfloat weight[4], GLdouble **dataOut ){    GLdouble *vertex;    int i;    doTessErrorCheck();    vertex = tesscache[tessBase+tessPtr];//(GLdouble *) malloc(6 * sizeof(GLdouble));    tessPtr++;    vertex[0] = coords[0];    vertex[1] = coords[1];    vertex[2] = coords[2];    for (i = 3; i < 7; i++)      vertex[i] = weight[0] * vertex_data[0][i] 	+ weight[1] * vertex_data[1][i]	+ weight[2] * vertex_data[2][i] 	+ weight[3] * vertex_data[3][i];    *dataOut = vertex;  }      void JTTESSCALLBACK JTTess_beginCallback(GLenum which){    glBegin(which);  }    void JTTESSCALLBACK JTTess_endCallback(void)  {    glEnd();  }    void JTTESSCALLBACK JTTess_errorCallback(GLenum errorCode)  {    const GLubyte *estring;        estring = gluErrorString(errorCode);    fprintf (stderr, "Tessellation Error: %s\n", estring);    exit (0);  }      /*  new callback routines registered by these calls */  void JTTESSCALLBACK JTTess_vertexCallback(GLvoid *vertex){    const GLdouble *pointer;        pointer = (GLdouble *) vertex;    glColor3dv(pointer+3);    glVertex3dv((const GLdouble*)vertex);  }        JoshFont *getFont(){    return font;  }    JPoint mouse(){    return JPoint(mouseX(),mouseY(),0);  }          /* allocates new storage for an 8-bit image of the specified dimensions   */  png_bytep* make_pixels(int width, int height) {    int pixel_size = 3;    //printf("debug debug debug 1\n",0);    png_structp png_ptr = png_create_read_struct(PNG_LIBPNG_VER_STRING, NULL, NULL, NULL);    if (png_ptr == NULL) {            return NULL;    }    //printf("debug debug debug 2\n",0);    png_bytep *row_pointers = (unsigned char **)png_malloc(png_ptr, height*sizeof(png_bytep));    for (int i = 0; i < height; i++)      row_pointers[i] = (unsigned char *)png_malloc(png_ptr, width*pixel_size);    //printf("debug debug debug 3\n",0);        return row_pointers;  }  //--------------------------------------------------------------------------------------------    void jt_frameRate(unsigned long f){    frameRate = f;  }      void roundedRect(int gl_style,float x1,float y1,float x2,float y2,float radius,int steps){    float inc = (PI*0.5)/steps;    glBegin(gl_style);    //draw a quarter circle here.        for(int i=0;i<steps;i++){      float x = radius*cos(inc*i-PI*0.5) + x2 - radius;      float y = radius*sin(inc*i-PI*0.5) + y1 + radius;      glVertex2f(x,y);    }            for(int i=0;i<steps;i++){      float x = radius*cos(inc*i) + x2 - radius;      float y = radius*sin(inc*i) + y2 - radius;      glVertex2f(x,y);    }            for(int i=0;i<steps;i++){      float x = radius*cos(inc*i+PI*0.5) + x1 + radius;      float y = radius*sin(inc*i+PI*0.5) + y2 - radius;      glVertex2f(x,y);    }            for(int i=0;i<steps;i++){      float x = radius*cos(inc*i+PI) + x1 + radius;      float y = radius*sin(inc*i+PI) + y1 + radius;      glVertex2f(x,y);    }                glEnd();  }    /*  ColorRGB getScreenPixel(int x,int y){    unsigned char rawpixels[4];    glReadPixels(x,height()-1-y,1,1, GL_RGB , GL_UNSIGNED_BYTE ,rawpixels);    return ColorRGB(		    rawpixels[0]/255.0,		    rawpixels[1]/255.0,		    rawpixels[2]/255.0		    );      }  */  };